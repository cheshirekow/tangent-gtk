// Copyright 2019 Josh Bialkowski <josh.bialkowski@gmail.com>

#include "tangent/gtkutil/serializemodels.h"

#include <iomanip>
#include <iostream>
#include <sstream>

#include <fmt/format.h>
#include <fmt/ostream.h>
#include <gtk/gtk.h>

#include "tangent/gtkutil/panzoomarea.h"
#include "tangent/json/parse.h"
#include "tangent/json/util.h"

void serialize_value(std::ostream* out, const char* name_str, double value) {
  fmt::print(*out, "\"{}\": {:8.4f},\n", name_str, value);
}

void serialize_value(std::ostream* out, const char* name_str, bool value) {
  fmt::print(*out, "\"{}\": {},\n", name_str, value ? "true" : "false");
}

void serialize_value(std::ostream* out, const char* name_str,
                     const gchar* value) {
  fmt::print(*out, "\"{}\": \"", name_str);
  json::escape(value, out);
  (*out) << "\",\n";
}

void serialize_object(std::ostream* out, GtkBuilder* builder,
                      tinyxml2::XMLElement* elem) {
  const char* class_str = elem->Attribute("class");
  const char* name_str = elem->Attribute("id");

  if (!name_str) {
    return;
  }
  GObject* obj = gtk_builder_get_object(builder, name_str);
  if (!obj) {
    return;
  }

  switch (json::runtime_hash(class_str)) {
    case json::hash("GtkAdjustment"): {
      double value = gtk_adjustment_get_value(GTK_ADJUSTMENT(obj));
      serialize_value(out, name_str, value);
      break;
    }
    case json::hash("GtkCheckButton"):
    case json::hash("GtkToggleButton"):
    case json::hash("GtkRadioButton"): {
      bool value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(obj));
      serialize_value(out, name_str, value);
      break;
    }
    case json::hash("GtkColorButton"): {
      GdkRGBA color;
      gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(obj), &color);
      gchar* value = gdk_rgba_to_string(&color);
      serialize_value(out, name_str, value);
      g_free(value);
      break;
    }
    case json::hash("GtkComboBoxText"): {
      gchar* value =
          gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(obj));
      if (value) {
        serialize_value(out, name_str, value);
        g_free(value);
      }
      break;
    }
    case json::hash("GtkEntryBuffer"): {
      const gchar* value = gtk_entry_buffer_get_text(GTK_ENTRY_BUFFER(obj));
      serialize_value(out, name_str, value);
      break;
    }
    case json::hash("GtkTextBuffer"): {
      GtkTextIter start;
      GtkTextIter end;
      gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(obj), &start);
      gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(obj), &end);
      gchar* value =
          gtk_text_buffer_get_text(GTK_TEXT_BUFFER(obj), &start, &end,
                                   /*include_hidden_chars=*/false);
      serialize_value(out, name_str, value);
      g_free(value);
      break;
    }

    case json::hash("GtkPanZoomArea"): {
      fmt::print(*out, "\"{}\": {{\n", name_str);
      double offset[2] = {0, 0};
      gtk_panzoom_area_get_offset(GTK_PANZOOM_AREA(obj), offset);
      fmt::print(*out, "\"{}\": [{}, {}]\n", "offset", offset[0], offset[1]);
      serialize_value(out, "scale",
                      gtk_panzoom_area_get_scale(GTK_PANZOOM_AREA(obj)));
      serialize_value(out, "scale_rate",
                      gtk_panzoom_area_get_scale_rate(GTK_PANZOOM_AREA(obj)));
      (*out) << "},";
      break;
    }

    default: {
      fmt::print(std::cerr, "No  known dumper for {}\n", class_str);
    }
      // TODO(josh): GtkPaned so we can preserve pane locations
  }
}

void serialize_recurse(std::ostream* out, GtkBuilder* builder,
                       tinyxml2::XMLElement* elmnt) {
  tinyxml2::XMLElement* obj;
  tinyxml2::XMLElement* child;

  // iterate over all objects
  obj = elmnt->FirstChildElement("object");
  while (obj) {
    serialize_object(out, builder, obj);
    serialize_recurse(out, builder, obj);
    obj = obj->NextSiblingElement("object");
  }

  // iterate over all children and recurse into
  child = elmnt->FirstChildElement("child");
  while (child) {
    serialize_recurse(out, builder, child);
    child = child->NextSiblingElement("child");
  }
}

static const char* OBJECT_KEY = "builder_models";

void serialize_models(std::ostream* out, GtkBuilder* builder,
                      tinyxml2::XMLElement* elmnt) {
  fmt::print(*out, "\"{}\": {{\n", OBJECT_KEY);
  serialize_recurse(out, builder, elmnt);
  // NOTE(josh): adding an extra field allows us to cheat and indescriminantly
  // include a comma after each field we write out.
  fmt::print(*out, "\"_comment\": \"Generated by tangent-gtk\"\n");
  fmt::print(*out, "}}\n");
}

int deserialize_models(const std::string& content, GtkBuilder* builder) {
  json::Error error{};
  json::LexerParser parser{};
  parser.init(&error);
  if (error.code != json::Error::NOERROR) {
    fmt::print(stderr, "WARNING: failed to init json parser: {}\n", error.msg);
    return -1;
  }
  parser.begin(content);
  return deserialize_models(&parser, builder);
}

void parse_token(const json::Token& token, GObject* object) {
  switch (token.typeno) {
    case json::Token::STRING_LITERAL: {
      // NOTE(josh): strip quotes
      re2::StringPiece escaped_value =
          token.spelling.substr(1, token.spelling.size() - 2);
      std::string value = json::unescape(escaped_value);
      if (G_OBJECT_TYPE(object) == GTK_TYPE_COMBO_BOX_TEXT) {
        fmt::print(std::cerr,
                   "WARNING: deserialize combo-box is not implemented\n");
      } else if (G_OBJECT_TYPE(object) == GTK_TYPE_ENTRY_BUFFER) {
        gtk_entry_buffer_set_text(GTK_ENTRY_BUFFER(object), &value[0],
                                  value.size());
      } else if (G_OBJECT_TYPE(object) == GTK_TYPE_TEXT_BUFFER) {
        gtk_text_buffer_set_text(GTK_TEXT_BUFFER(object), &value[0],
                                 value.size());
      } else if (G_OBJECT_TYPE(object) == GTK_TYPE_COLOR_BUTTON) {
        GdkRGBA color;
        if (gdk_rgba_parse(&color, value.c_str())) {
          gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(object), &color);
        } else {
          fmt::print(std::cerr,
                     "WARNING: failed to parse color string \"{}\"\n", value);
        }

      } else {
        fmt::print(std::cerr,
                   "WARNING: don't know how to deserialize a string literal "
                   "into a {}\n",
                   G_OBJECT_TYPE_NAME(object));
      }
      break;
    }
    case json::Token::NUMERIC_LITERAL: {
      gdouble value = 0;
      json::parse_real_number(token, &value);
      if (G_OBJECT_TYPE(object) == GTK_TYPE_ADJUSTMENT) {
        gtk_adjustment_set_value(GTK_ADJUSTMENT(object), value);
      } else {
        fmt::print(std::cerr,
                   "WARNING: don't know how to deserialize a numeric literal "
                   "into a {}\n",
                   G_OBJECT_TYPE_NAME(object));
      }
      break;
    }
    case json::Token::BOOLEAN_LITERAL: {
      bool value = false;
      json::parse_boolean(token, &value);
      if (G_OBJECT_TYPE(object) == GTK_TYPE_CHECK_BUTTON ||
          G_OBJECT_TYPE(object) == GTK_TYPE_TOGGLE_BUTTON ||
          G_OBJECT_TYPE(object) == GTK_TYPE_RADIO_BUTTON) {
        gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(object), value);
      } else {
        fmt::print(std::cerr,
                   "WARNING: don't know how to deserialize a boolean literal "
                   "into a {}\n",
                   G_OBJECT_TYPE_NAME(object));
      }
      break;
    }
    default:
      fmt::print(std::cerr, "WARNING: unable to parse json token of type {}\n",
                 json::Token::to_string(token.typeno));
  }
}

static int parsefield_panzoom_area(const json::stream::Registry& registry,
                                   const re2::StringPiece& key,
                                   json::LexerParser* stream,
                                   GtkPanZoomArea* out) {
  uint64_t keyid = json::runtime_hash(key);
  switch (keyid) {
    case json::hash("offset"): {
      double offset[2] = {0, 0};
      int result = registry.parse_list(stream, &offset);
      gtk_panzoom_area_set_offset(out, offset);
      return result;
    }
    case json::hash("scale"): {
      double value = 0;
      int result = registry.parse_value(stream, &value);
      if (value < 0.001) {
        value = 0.001;
      }
      gtk_panzoom_area_set_scale(out, value);
      return result;
    }
    case json::hash("scale_rate"): {
      double value = 0;
      int result = registry.parse_value(stream, &value);
      if (value < 0.001) {
        value = 0.001;
      }
      gtk_panzoom_area_set_scale_rate(out, value);
      return result;
    }
    default:
      sink_value(stream);
      return 1;
  }
  return 0;
}

int dumpfields_panzoom_area(const GtkPanZoomArea& out,
                            json::stream::Dumper* dumper) {
  int result = 0;
  double offset[2] = {0, 0};

  gtk_panzoom_area_get_offset(const_cast<GtkPanZoomArea*>(&out), offset);
  result |= dumper->dump_field("offset", offset);
  result |= dumper->dump_field(
      "scale", gtk_panzoom_area_get_scale(const_cast<GtkPanZoomArea*>(&out)));
  result |= dumper->dump_field(
      "scale_rate",
      gtk_panzoom_area_get_scale_rate(const_cast<GtkPanZoomArea*>(&out)));
  return result;
}

void parse_object(json::LexerParser* stream, GObject* object) {
  if (GTK_IS_PANZOOM_AREA(object)) {
    // TODO(josh): create the registry in the main function
    json::stream::Registry registry;
    registry.register_object(&parsefield_panzoom_area,
                             &dumpfields_panzoom_area);
    registry.parse_object(stream, GTK_PANZOOM_AREA(object));
  } else {
    fmt::print(std::cerr, "WARNING: unknown GTK type for json object\n");
    json::sink_object(stream);
  }
}

int deserialize_object(json::LexerParser* parser, GtkBuilder* builder) {
  json::Error error{};
  json::Event event{};

  std::string object_key;
  size_t event_count = 0;
  while (parser->peek_next_event(&event, &error) == 0) {
    switch (event.typeno) {
      case json::Event::OBJECT_BEGIN: {
        // We allow the function to be called with the object open queued
        // up
        if (event_count >= 0) {
          if (object_key.empty()) {
            json::sink_object(parser);
            continue;
          }

          GObject* obj = gtk_builder_get_object(builder, object_key.c_str());
          if (obj) {
            parse_object(parser, obj);
          } else {
            fmt::print(
                stderr,
                "WARNING: unrecognized object in json with key : \"{}\"\n",
                object_key);
            json::sink_object(parser);
          }
          continue;  // don't consume the event, that was done by sink_object
        }
        break;
      }

      case json::Event::OBJECT_KEY: {
        object_key =
            event.token.spelling.substr(1, event.token.spelling.size() - 2)
                .as_string();
        break;
      }

      case json::Event::VALUE_LITERAL: {
        if (object_key.empty()) {
          break;
        }
        GObject* obj = gtk_builder_get_object(builder, object_key.c_str());
        if (obj) {
          parse_token(event.token, obj);
        } else {
          fmt::print(stderr, "WARNING: unrecognized key in json: \"{}\"\n",
                     object_key);
        }
        break;
      }

      case json::Event::OBJECT_END: {
        return 0;
      }

      default: {
        return -3;
      }
    }
    event_count++;
    parser->get_next_event(&event, &error);
  }

  if (error.code != json::Error::LEX_INPUT_FINISHED) {
    fmt::print(stderr, "WARNING: {}", error.msg);
    return -1;
  }
  return 0;
}

int deserialize_models(json::LexerParser* parser, GtkBuilder* builder) {
  json::Error error{};
  json::Event event{};

  size_t object_depth = 0;
  bool object_key_matched = false;

  while (parser->get_next_event(&event, &error) == 0) {
    switch (event.typeno) {
      case json::Event::OBJECT_BEGIN:
        if (object_depth == 1 && object_key_matched) {
          return deserialize_object(parser, builder);
        }
        object_depth++;
        object_key_matched = false;
        break;
      case json::Event::OBJECT_END:
        object_depth--;
        object_key_matched = false;
        break;
      case json::Event::OBJECT_KEY: {
        if (object_depth != 1) {
          break;
        }
        re2::StringPiece key_str =
            event.token.spelling.substr(1, event.token.spelling.size() - 2);
        if (key_str == OBJECT_KEY) {
          object_key_matched = true;
        }
        break;
      }
      default:
        break;
    }
  }
  if (error.code == json::Error::LEX_INPUT_FINISHED) {
    return 0;
  }
  fmt::print(stderr, "WARNING: failed to parse json: {}\n", error.msg);
  return -1;
}

static void dump_object(json::stream::Dumper* dumper, GtkBuilder* builder,
                        tinyxml2::XMLElement* elem) {
  const char* class_str = elem->Attribute("class");
  const char* name_str = elem->Attribute("id");

  if (!name_str) {
    return;
  }
  GObject* obj = gtk_builder_get_object(builder, name_str);
  if (!obj) {
    return;
  }

  switch (json::runtime_hash(class_str)) {
    case json::hash("GtkAdjustment"): {
      double value = gtk_adjustment_get_value(GTK_ADJUSTMENT(obj));
      dumper->dump_field(name_str, value);
      break;
    }
    case json::hash("GtkCheckButton"):
    case json::hash("GtkToggleButton"):
    case json::hash("GtkRadioButton"): {
      bool value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(obj));
      dumper->dump_field(name_str, value);
      break;
    }
    case json::hash("GtkColorButton"): {
      GdkRGBA color;
      gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(obj), &color);
      gchar* value = gdk_rgba_to_string(&color);
      dumper->dump_field(name_str, value);
      g_free(value);
      break;
    }
    case json::hash("GtkComboBoxText"): {
      gchar* value =
          gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(obj));
      if (value) {
        dumper->dump_field(name_str, value);
        g_free(value);
      }
      break;
    }
    case json::hash("GtkEntryBuffer"): {
      const gchar* value = gtk_entry_buffer_get_text(GTK_ENTRY_BUFFER(obj));
      dumper->dump_field(name_str, value);
      break;
    }
    case json::hash("GtkTextBuffer"): {
      GtkTextIter start;
      GtkTextIter end;
      gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(obj), &start);
      gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(obj), &end);
      gchar* value =
          gtk_text_buffer_get_text(GTK_TEXT_BUFFER(obj), &start, &end,
                                   /*include_hidden_chars=*/false);
      dumper->dump_field(name_str, value);
      g_free(value);
      break;
    }

    case json::hash("GtkPanZoomArea"): {
      dumper->dump_event(json::stream::DumpEvent::OBJECT_KEY);
      dumper->dump_primitive(name_str);
      dumper->dump_event(json::stream::DumpEvent::OBJECT_VALUE);
      json::stream::DumpGuard objscope{dumper, json::stream::GUARD_OBJECT};
      double offset[2] = {0, 0};
      gtk_panzoom_area_get_offset(GTK_PANZOOM_AREA(obj), offset);
      dumper->dump_field("offset", offset);
      dumper->dump_field("scale",
                         gtk_panzoom_area_get_scale(GTK_PANZOOM_AREA(obj)));
      dumper->dump_field(
          "scale_rate", gtk_panzoom_area_get_scale_rate(GTK_PANZOOM_AREA(obj)));
      break;
    }

      // TODO(josh): GtkPaned so we can preserve pane locations
  }
}

void dump_recurse(json::stream::Dumper* dumper, GtkBuilder* builder,
                  tinyxml2::XMLElement* elmnt) {
  tinyxml2::XMLElement* obj;
  tinyxml2::XMLElement* child;

  // iterate over all objects
  obj = elmnt->FirstChildElement("object");
  while (obj) {
    dump_object(dumper, builder, obj);
    dump_recurse(dumper, builder, obj);
    obj = obj->NextSiblingElement("object");
  }

  // iterate over all children and recurse into
  child = elmnt->FirstChildElement("child");
  while (child) {
    dump_recurse(dumper, builder, child);
    child = child->NextSiblingElement("child");
  }
}

int GtkBuilderPair::parsefield(const json::stream::Registry& registry,
                               const re2::StringPiece& key,
                               json::LexerParser* stream, GtkBuilderPair* out) {
  return deserialize_object(stream, out->builder);
}

int GtkBuilderPair::dumpfields(const GtkBuilderPair& out,
                               json::stream::Dumper* dumper) {
  dump_recurse(dumper, out.builder, out.document->RootElement());
  return 0;
}
