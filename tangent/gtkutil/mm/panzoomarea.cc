// Generated by gmmproc 2.56.0 -- DO NOT MODIFY!

#include <glibmm.h>

#include <tangent/gtkutil/mm/panzoomarea.h>
#include <tangent/gtkutil/mm/private/panzoomarea_p.h>

#include "tangent/gtkutil/panzoomarea.h"

using CairoContext = cairo_t;

namespace {

static gboolean PanZoomArea_signal_area_motion_callback(GtkPanZoomArea* self,
                                                        GdkEventMotion* p0,
                                                        void* data) {
  using namespace Gtk;
  using SlotType = sigc::slot<bool, GdkEventMotion*>;

  auto obj = dynamic_cast<PanZoomArea*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));
  // Do not try to call a signal on a disassociated wrapper.
  if (obj) {
    try {
      if (const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    } catch (...) {
      Glib::exception_handlers_invoke();
    }
  }

  using RType = gboolean;
  return RType();
}

static gboolean PanZoomArea_signal_area_motion_notify_callback(
    GtkPanZoomArea* self, GdkEventMotion* p0, void* data) {
  using namespace Gtk;
  using SlotType = sigc::slot<void, GdkEventMotion*>;

  auto obj = dynamic_cast<PanZoomArea*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));
  // Do not try to call a signal on a disassociated wrapper.
  if (obj) {
    try {
      if (const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    } catch (...) {
      Glib::exception_handlers_invoke();
    }
  }

  using RType = gboolean;
  return RType();
}

static const Glib::SignalProxyInfo PanZoomArea_signal_area_motion_info = {
    "area-motion", (GCallback)&PanZoomArea_signal_area_motion_callback,
    (GCallback)&PanZoomArea_signal_area_motion_notify_callback};

static gboolean PanZoomArea_signal_area_button_callback(GtkPanZoomArea* self,
                                                        GdkEventButton* p0,
                                                        void* data) {
  using namespace Gtk;
  using SlotType = sigc::slot<bool, GdkEventButton*>;

  auto obj = dynamic_cast<PanZoomArea*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));
  // Do not try to call a signal on a disassociated wrapper.
  if (obj) {
    try {
      if (const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>((*static_cast<SlotType*>(slot))(p0));
    } catch (...) {
      Glib::exception_handlers_invoke();
    }
  }

  using RType = gboolean;
  return RType();
}

static gboolean PanZoomArea_signal_area_button_notify_callback(
    GtkPanZoomArea* self, GdkEventButton* p0, void* data) {
  using namespace Gtk;
  using SlotType = sigc::slot<void, GdkEventButton*>;

  auto obj = dynamic_cast<PanZoomArea*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));
  // Do not try to call a signal on a disassociated wrapper.
  if (obj) {
    try {
      if (const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(p0);
    } catch (...) {
      Glib::exception_handlers_invoke();
    }
  }

  using RType = gboolean;
  return RType();
}

static const Glib::SignalProxyInfo PanZoomArea_signal_area_button_info = {
    "area-button", (GCallback)&PanZoomArea_signal_area_button_callback,
    (GCallback)&PanZoomArea_signal_area_button_notify_callback};

static gboolean PanZoomArea_signal_area_draw_callback(GtkPanZoomArea* self,
                                                      CairoContext* p0,
                                                      void* data) {
  using namespace Gtk;
  using SlotType = sigc::slot<bool, const ::Cairo::RefPtr< ::Cairo::Context>&>;

  auto obj = dynamic_cast<PanZoomArea*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));
  // Do not try to call a signal on a disassociated wrapper.
  if (obj) {
    try {
      if (const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        return static_cast<int>(
            (*static_cast<SlotType*>(slot))(::Cairo::RefPtr< ::Cairo::Context>(
                new ::Cairo::Context(p0, false /* has_reference */))));
    } catch (...) {
      Glib::exception_handlers_invoke();
    }
  }

  using RType = gboolean;
  return RType();
}

static gboolean PanZoomArea_signal_area_draw_notify_callback(
    GtkPanZoomArea* self, CairoContext* p0, void* data) {
  using namespace Gtk;
  using SlotType = sigc::slot<void, const ::Cairo::RefPtr< ::Cairo::Context>&>;

  auto obj = dynamic_cast<PanZoomArea*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));
  // Do not try to call a signal on a disassociated wrapper.
  if (obj) {
    try {
      if (const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(::Cairo::RefPtr< ::Cairo::Context>(
            new ::Cairo::Context(p0, false /* has_reference */)));
    } catch (...) {
      Glib::exception_handlers_invoke();
    }
  }

  using RType = gboolean;
  return RType();
}

static const Glib::SignalProxyInfo PanZoomArea_signal_area_draw_info = {
    "area-draw", (GCallback)&PanZoomArea_signal_area_draw_callback,
    (GCallback)&PanZoomArea_signal_area_draw_notify_callback};

}  // anonymous namespace

namespace Glib {

Gtk::PanZoomArea* wrap(GtkPanZoomArea* object, bool take_copy) {
  return dynamic_cast<Gtk::PanZoomArea*>(
      Glib::wrap_auto((GObject*)(object), take_copy));
}

} /* namespace Glib */

namespace Gtk {

/* The *_Class implementation: */

const Glib::Class& PanZoomArea_Class::init() {
  if (!gtype_)  // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &PanZoomArea_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    // CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base
    // type.
    register_derived_type(gtk_panzoom_area_get_type());

    // Add derived versions of interfaces, if the C type implements any
    // interfaces:
  }

  return *this;
}

void PanZoomArea_Class::class_init_function(void* g_class, void* class_data) {
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

  klass->area_motion = &area_motion_callback;
  klass->area_button = &area_button_callback;
  klass->area_draw = &area_draw_callback;
}

gboolean PanZoomArea_Class::area_motion_callback(GtkPanZoomArea* self,
                                                 GdkEventMotion* p0) {
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if (obj_base && obj_base->is_derived_()) {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if (obj)  // This can be NULL during destruction.
    {
      try  // Trap C++ exceptions which would normally be lost because this is a
           // C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->on_area_motion(p0));
      } catch (...) {
        Glib::exception_handlers_invoke();
      }
    }
  }

  const auto base = static_cast<BaseClassType*>(g_type_class_peek_parent(
      G_OBJECT_GET_CLASS(self))  // Get the parent class of the object class
                                 // (The original underlying C class).
  );

  // Call the original underlying C function:
  if (base && base->area_motion) return (*base->area_motion)(self, p0);

  using RType = gboolean;
  return RType();
}
gboolean PanZoomArea_Class::area_button_callback(GtkPanZoomArea* self,
                                                 GdkEventButton* p0) {
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if (obj_base && obj_base->is_derived_()) {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if (obj)  // This can be NULL during destruction.
    {
      try  // Trap C++ exceptions which would normally be lost because this is a
           // C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(obj->on_area_button(p0));
      } catch (...) {
        Glib::exception_handlers_invoke();
      }
    }
  }

  const auto base = static_cast<BaseClassType*>(g_type_class_peek_parent(
      G_OBJECT_GET_CLASS(self))  // Get the parent class of the object class
                                 // (The original underlying C class).
  );

  // Call the original underlying C function:
  if (base && base->area_button) return (*base->area_button)(self, p0);

  using RType = gboolean;
  return RType();
}
gboolean PanZoomArea_Class::area_draw_callback(GtkPanZoomArea* self,
                                               CairoContext* p0) {
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if (obj_base && obj_base->is_derived_()) {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if (obj)  // This can be NULL during destruction.
    {
      try  // Trap C++ exceptions which would normally be lost because this is a
           // C callback.
      {
        // Call the virtual member method, which derived classes might override.
        return static_cast<int>(
            obj->on_area_draw(::Cairo::RefPtr< ::Cairo::Context>(
                new ::Cairo::Context(p0, false /* has_reference */))));
      } catch (...) {
        Glib::exception_handlers_invoke();
      }
    }
  }

  const auto base = static_cast<BaseClassType*>(g_type_class_peek_parent(
      G_OBJECT_GET_CLASS(self))  // Get the parent class of the object class
                                 // (The original underlying C class).
  );

  // Call the original underlying C function:
  if (base && base->area_draw) return (*base->area_draw)(self, p0);

  using RType = gboolean;
  return RType();
}

Glib::ObjectBase* PanZoomArea_Class::wrap_new(GObject* o) {
  return manage(new PanZoomArea((GtkPanZoomArea*)(o)));
}

/* The implementation: */

PanZoomArea::PanZoomArea(const Glib::ConstructParams& construct_params)
    : Gtk::DrawingArea(construct_params) {}

PanZoomArea::PanZoomArea(GtkPanZoomArea* castitem)
    : Gtk::DrawingArea((GtkDrawingArea*)(castitem)) {}

PanZoomArea::PanZoomArea(PanZoomArea&& src) noexcept
    : Gtk::DrawingArea(std::move(src)) {}

PanZoomArea& PanZoomArea::operator=(PanZoomArea&& src) noexcept {
  Gtk::DrawingArea::operator=(std::move(src));
  return *this;
}

PanZoomArea::~PanZoomArea() noexcept {
  destroy_();
}

PanZoomArea::CppClassType
    PanZoomArea::panzoomarea_class_;  // initialize static member

GType PanZoomArea::get_type() {
  return panzoomarea_class_.init().get_type();
}

GType PanZoomArea::get_base_type() {
  return gtk_panzoom_area_get_type();
}

PanZoomArea::PanZoomArea()
    :  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
      Glib::ObjectBase(nullptr),
      Gtk::DrawingArea(Glib::ConstructParams(panzoomarea_class_.init())) {}

double PanZoomArea::get_scale() {
  return gtk_panzoom_area_get_scale(gobj());
}

void PanZoomArea::set_scale(double scale) {
  gtk_panzoom_area_set_scale(gobj(), scale);
}

double PanZoomArea::get_scale_rate() {
  return gtk_panzoom_area_get_scale_rate(gobj());
}

void PanZoomArea::set_scale_rate(double rate) {
  gtk_panzoom_area_set_scale_rate(gobj(), rate);
}

Glib::SignalProxy<bool, GdkEventMotion*> PanZoomArea::signal_area_motion() {
  return Glib::SignalProxy<bool, GdkEventMotion*>(
      this, &PanZoomArea_signal_area_motion_info);
}

Glib::SignalProxy<bool, GdkEventButton*> PanZoomArea::signal_area_button() {
  return Glib::SignalProxy<bool, GdkEventButton*>(
      this, &PanZoomArea_signal_area_button_info);
}

Glib::SignalProxy<bool, const ::Cairo::RefPtr< ::Cairo::Context>&>
PanZoomArea::signal_area_draw() {
  return Glib::SignalProxy<bool, const ::Cairo::RefPtr< ::Cairo::Context>&>(
      this, &PanZoomArea_signal_area_draw_info);
}

Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_offset_x_adjustment() {
  return Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >(
      this, "offset-x-adjustment");
}

Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_offset_x_adjustment() const {
  return Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >(
      this, "offset-x-adjustment");
}

Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_offset_y_adjustment() {
  return Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >(
      this, "offset-y-adjustment");
}

Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_offset_y_adjustment() const {
  return Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >(
      this, "offset-y-adjustment");
}

Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_scale_adjustment() {
  return Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >(
      this, "scale-adjustment");
}

Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_scale_adjustment() const {
  return Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >(
      this, "scale-adjustment");
}

Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_scale_rate_adjustment() {
  return Glib::PropertyProxy<Glib::RefPtr<Gtk::Adjustment> >(
      this, "scale-rate-adjustment");
}

Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >
PanZoomArea::property_scale_rate_adjustment() const {
  return Glib::PropertyProxy_ReadOnly<Glib::RefPtr<Gtk::Adjustment> >(
      this, "scale-rate-adjustment");
}

Glib::PropertyProxy<bool> PanZoomArea::property_active() {
  return Glib::PropertyProxy<bool>(this, "active");
}

Glib::PropertyProxy_ReadOnly<bool> PanZoomArea::property_active() const {
  return Glib::PropertyProxy_ReadOnly<bool>(this, "active");
}

Glib::PropertyProxy<int> PanZoomArea::property_pan_button() {
  return Glib::PropertyProxy<int>(this, "pan-button");
}

Glib::PropertyProxy_ReadOnly<int> PanZoomArea::property_pan_button() const {
  return Glib::PropertyProxy_ReadOnly<int>(this, "pan-button");
}

Glib::PropertyProxy<bool> PanZoomArea::property_demo_draw_enabled() {
  return Glib::PropertyProxy<bool>(this, "demo-draw-enabled");
}

Glib::PropertyProxy_ReadOnly<bool> PanZoomArea::property_demo_draw_enabled()
    const {
  return Glib::PropertyProxy_ReadOnly<bool>(this, "demo-draw-enabled");
}

bool Gtk::PanZoomArea::on_area_motion(GdkEventMotion* event) {
  const auto base = static_cast<BaseClassType*>(g_type_class_peek_parent(
      G_OBJECT_GET_CLASS(gobject_))  // Get the parent class of the object class
                                     // (The original underlying C class).
  );

  if (base && base->area_motion) return (*base->area_motion)(gobj(), event);

  using RType = bool;
  return RType();
}
bool Gtk::PanZoomArea::on_area_button(GdkEventButton* event) {
  const auto base = static_cast<BaseClassType*>(g_type_class_peek_parent(
      G_OBJECT_GET_CLASS(gobject_))  // Get the parent class of the object class
                                     // (The original underlying C class).
  );

  if (base && base->area_button) return (*base->area_button)(gobj(), event);

  using RType = bool;
  return RType();
}
bool Gtk::PanZoomArea::on_area_draw(
    const ::Cairo::RefPtr< ::Cairo::Context>& cr) {
  const auto base = static_cast<BaseClassType*>(g_type_class_peek_parent(
      G_OBJECT_GET_CLASS(gobject_))  // Get the parent class of the object class
                                     // (The original underlying C class).
  );

  if (base && base->area_draw) return (*base->area_draw)(gobj(), (cr)->cobj());

  using RType = bool;
  return RType();
}

}  // namespace Gtk
